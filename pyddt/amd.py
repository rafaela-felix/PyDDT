#!/usr/bin/python3
# -*- coding: utf-8 -*-

"""This class is used for performing compatibility analysis."""

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.lines import Line2D

from .crystal import Crystal
from .crystal_funcs import phase_triplet

__author__ = "Rafaela Felix"
__credits__ = {"Rafaela Felix", "Sergio MorelhÃ£o"}
__version__ = "1.0"
__maintainer__ = "Rafaela Felix"
__email__ = "rafaelafelixp@usp.br"
__status__ = "Production"

_params = {'font.size': 12,

           'axes.labelsize': 12,
           'axes.linewidth': 1,

           'figure.figsize': (10, 8),
           'figure.subplot.left': 0.125,
           'figure.subplot.right': 0.95,
           'figure.subplot.bottom': 0.1,
           'figure.subplot.top': 0.95,

           'savefig.dpi': 300,
           'savefig.format': 'png',

           'legend.fontsize': 7.5,
           'legend.frameon': False,
           'legend.numpoints': 1,
           'legend.handlelength': 2,
           'legend.scatterpoints': 1,
           'legend.labelspacing': 0.5,
           'legend.markerscale': 0.9,
           'legend.handletextpad': 0.5,  # pad between handle and text
           'legend.borderaxespad': 0.5,  # pad between legend and axes
           'legend.borderpad': 0.5,  # pad between legend and legend content
           'legend.columnspacing': 1,  # pad between each legend column

           'xtick.labelsize': 10,
           'ytick.labelsize': 10,

           'lines.linewidth': 1,
           'lines.markersize': 4,

           # Revert some properties to mpl v1 which is more suitable for publishing
           'axes.autolimit_mode': 'round_numbers',
           'axes.xmargin': 0,
           'axes.ymargin': 0,
           'xtick.direction': 'in',
           'xtick.top': True,
           'ytick.direction': 'in',
           'ytick.right': True,
           }

_params2 = {'font.size': 14,

            'axes.labelsize': 14,
            'axes.linewidth': 1,

            'figure.figsize': (10, 8),

            'savefig.dpi': 300,
            'savefig.format': 'png',

            'legend.fontsize': 7.5,
            'legend.frameon': False,
            'legend.numpoints': 1,
            'legend.handlelength': 2,
            'legend.scatterpoints': 1,
            'legend.labelspacing': 0.5,
            'legend.markerscale': 0.9,
            'legend.handletextpad': 0.5,  # pad between handle and text
            'legend.borderaxespad': 0.5,  # pad between legend and axes
            'legend.borderpad': 0.5,  # pad between legend and legend content
            'legend.columnspacing': 1,  # pad between each legend column

            'xtick.labelsize': 14,
            'ytick.labelsize': 14,

            'lines.linewidth': 1,
            'lines.markersize': 4,
            }


class AMD:

    def __init__(self, fexp: str, mnames: list = []):

        """Given the experimental asymmetries and structural models, returns a new ``amd`` object.

        Args:
            fexp (str): Filename of experimental asymmetries.
            mnames (list): Names of *.in* files (structural models).

        Notes:
            * `fexp` file must present *hkl* indices, asymmetry type, and diffraction geometry in columns (this order),
              including primary reflection and X-ray energy in 1st line. This file is automatically generated by the
              ``expdata`` class (*.red* extension).

        """

        self.theo_asy = None
        self.matrix = None
        self._mult = None
        self.hkl = np.loadtxt(fexp, usecols=(0, 1, 2), skiprows=2)
        self.asy = np.loadtxt(fexp, usecols=3, dtype=str, skiprows=2)
        self.s = np.loadtxt(fexp, usecols=4, skiprows=2)
        self.primary = np.loadtxt(fexp, usecols=(0, 1, 2), max_rows=2)
        self.energy = np.loadtxt(fexp, usecols=3, max_rows=2)
        self.names = mnames

        self.HKL = [str(int(self.hkl[i, 0])) + ' ' + str(int(self.hkl[i, 1])) + ' ' + str(int(self.hkl[i, 2])) for i in
                    range(len(self.hkl))]
        self.numeric_asy = [1 if t == 'HL' else 0 for t in self.asy]
        self._n = int(np.ceil(np.sqrt(len(self.asy))))

        label = np.append(self.HKL, np.zeros(self._n ** 2 - len(self.hkl), dtype=str)).reshape((self._n, self._n))[::-1]
        label = np.flip(label, axis=0)
        label[label == ''] = ' - '

        self.labels = label

    @mpl.rc_context(_params)
    def experimental_asymmetries(self, hl: str or tuple = 'cyan', lh: str or tuple = 'gold'):

        """Shows the experimental asymmetries in the diagram.

        Args:
            hl (str or tuple): Color of HL asymmetries. **Default**: cyan.
            lh (str or tuple): Color of LH asymmetries. **Default**: gold.

        Notes:
            `hl` and `lh` must be color names or RGB values ranging between 0 and 1.

        Usage:
            * ``exp_plot('red', 'blue')``
            * ``exp_plot((1, 0, 0), (0, 0, 1))``

        """

        M = np.append(self.numeric_asy, np.zeros(self._n ** 2 - len(self.hkl))).reshape((self._n, self._n))

        cmap = plt.get_cmap('PRGn').copy()  # Colormap
        cmap.set_under(lh)
        cmap.set_over(hl)

        custom_lines = [Line2D([0], [0], marker='s', color=hl, lw=0.01, markersize=10),  # Customized legend
                        Line2D([0], [0], marker='s', color=lh, lw=0.01, markersize=10)]

        fig = plt.figure()
        ax = fig.add_subplot(1, 1, 1)

        ax.pcolormesh(M, cmap=cmap, vmin=0.5, vmax=0.6)
        ax.hlines(y=np.arange(0, self._n + 1), xmin=0, xmax=self._n, color="k", linewidth=.5)
        ax.vlines(x=np.arange(0, self._n + 1), ymin=0, ymax=self._n, color="k", linewidth=.5)

        for y in range(0, self._n):
            for x in range(0, self._n):
                ax.text(x + 0.5, y + 0.5, str(self.labels[y, x]), horizontalalignment='center',
                        verticalalignment='center', weight='bold')

        ax.set_aspect('equal')
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)
        ax.legend(custom_lines, ['HL', 'LH'], loc='upper left', bbox_to_anchor=(1, 1), prop={'size': 14})

        plt.show()

    @mpl.rc_context(_params)
    def diagram_positions(self):

        """Shows the MD positions in the asymmetry matching diagram."""

        cmap = mpl.colors.ListedColormap(['whitesmoke'])

        fig = plt.figure()
        ax = fig.add_subplot(1, 1, 1)
        ax.pcolormesh(np.ones((self._n, self._n)), cmap=cmap)

        for y in range(0, self._n):
            for x in range(0, self._n):
                ax.text(x + 0.5, y + 0.5, str(self.labels[y, x]),
                        horizontalalignment='center', verticalalignment='center', weight='bold')

        ax.set_aspect('equal')
        ax.get_xaxis().set_visible(False)
        ax.get_yaxis().set_visible(False)

        ax.hlines(y=np.arange(0, self._n + 1), xmin=0, xmax=self._n, color="k", linewidth=.5)
        ax.vlines(x=np.arange(0, self._n + 1), ymin=0, ymax=self._n, color="k", linewidth=.5)

        plt.show()

    def theoretical_asymmetries(self):

        """Calculates the theoretical asymmetries."""

        GH = self.primary - self.hkl  # coupling reflection

        i = 0
        for name in self.names:

            crystal = Crystal(name)
            FG = crystal.Fhkl(self.energy, self.primary)
            FH = crystal.Fhkl(self.energy, self.hkl)
            FGH = crystal.Fhkl(self.energy, GH)

            cosPsi = phase_triplet(FG, FH, FGH)[0]

            if i == 0:
                cosT = cosPsi[:]
            else:
                cosT = np.row_stack((cosT, cosPsi))

            i += 1

        data = cosT * self.s
        data[data > 0] = 1
        data[data < 0] = 0

        self.theo_asy = data

    def matching_matrix(self):

        """Generates the matching matrix."""

        self.theoretical_asymmetries()

        m = int(np.sqrt(len(self.names)))
        M = np.zeros((m * self._n, m * self._n))

        for i in range(0, m):
            var_y = self.theo_asy[i * m:i * m + m, :]
            for j in range(0, m):
                var_x = var_y[j, :]
                R = np.zeros(self._n ** 2)
                for k in range(len(var_x)):
                    if var_x[k] == self.numeric_asy[k]:
                        R[k] = 1
                kp = len(var_x)
                for l in range(kp, kp + self._n ** 2 - len(self.asy)):
                    R[l] = 0.5

                R = np.reshape(R, (self._n, self._n))
                M[self._n * i:self._n * (i + 1), self._n * j:self._n * (j + 1)] = R[:, :]

        self._mult = self._n * m
        self.matrix = M

    @mpl.rc_context(_params2)
    def twovariable_plot(self, xmax: float, xmin: float, dx: float,
             ymax: float, ymin: float, dy: float, xlabel: str = 'x', ylabel: str = 'y',
             color_empty: str or tuple = 'whitesmoke', incp: str or tuple = 'red', cp: str or tuple = 'lime',
             showlegend: bool = True):

        """Plots the asymmetry matching diagram (AMD) for structural models with two differential variables.

        Args:
            xmax (float): Maximum value in horizontal axis.
            xmin (float): Minimum value in horizontal axis.
            dx (float): Step of the horizontal axis.
            ymax (float): Maximum value in vertical axis.
            ymin (float): Minimum value in vertical axis.
            dy (float): Step of the vertical axis.
            xlabel (str): Label for the horizontal axis. **Default**: *x*.
            ylabel (str): Label for the vertical axis. **Default**: *y*.
            color_empty (str or tuple): Color of the empty cells. **Default**: whitesmoke.
            incp (str or tuple): Color representing the incompatible cases. **Default**: red.
            cp (str or tuple): Color representing the compatible cases. **Default**: lime.
            showlegend (bool): Display legend (True/False). **Default**: ``True``.

        Notes:
            `color_empty`, `incp` and `cp` must be color names or RGB values ranging between 0 and 1.

        Usage:
            * ``plot(xmax=1, xmin=0, dx=0.1, ymax=60, ymin=10, dy=5, xlabel='H effective charge',
              ylabel='N displacement (pm)', color_empty='gray', incp='blue', cp='green')``
            * ``plot(xmax=1, xmin=0, dx=0.1, ymax=60, ymin=10, dy=5, xlabel='H effective charge',
              ylabel='N displacement (pm)', color_empty=(0.5, 0.5, 0.5), incp=(0, 0, 1), cp=(0, 1, 0))``

        """

        cmap = mpl.colors.ListedColormap([incp, color_empty, cp])
        cmap.set_under(incp)
        cmap.set_over(cp)

        custom_lines = [Line2D([0], [0], marker='s', color=incp, lw=0.01, markersize=10),  # Customized legend
                        Line2D([0], [0], marker='s', color=cp, lw=0.01, markersize=10)]

        fig = plt.figure()
        ax = fig.add_subplot(1, 1, 1)

        ax.pcolormesh(self.matrix, cmap=cmap, vmin=0.4, vmax=0.6)
        ax.hlines(y=np.arange(0, self._mult), xmin=0, xmax=self._mult, color="grey", linewidth=.5)
        ax.vlines(x=np.arange(0, self._mult), ymin=0, ymax=self._mult, color="grey", linewidth=.5)
        ax.hlines(y=np.arange(0, self._mult, self._n), xmin=0, xmax=self._mult, color="dimgray", linewidth=1.5)
        ax.vlines(x=np.arange(0, self._mult, self._n), ymin=0, ymax=self._mult, color="dimgray", linewidth=1.5)

        ax.set_xticks(ticks=np.arange(self._n / 2, self._mult, self._n),
                      labels=np.round(np.arange(xmin, xmax + dx, dx), 1))
        ax.set_yticks(ticks=np.arange(self._n / 2, self._mult, self._n),
                      labels=np.round(np.arange(ymin, ymax + dy, dy), 1))

        ax.set_aspect('equal')
        if showlegend:
            ax.legend(custom_lines, ['F', 'T'], loc='upper left', bbox_to_anchor=(1, 1), prop={'size': 14})

        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)

        plt.show()

    @mpl.rc_context(_params2)
    def onevariable_plot(self, ncols: int, nrows: int, color_empty: str or tuple = 'whitesmoke',
                         incp: str or tuple = 'red', cp: str or tuple = 'lime', showlegend: bool = True):

        """Plots the asymmetry matching diagram (AMD) for structural models with one differential variable.

        Args:
            ncols (int): Number of columns.
            nrows (int): Number of rows.
            color_empty (str or tuple): Color of the empty cells. **Default**: whitesmoke.
            incp (str or tuple): Color representing the incompatible cases. **Default**: red.
            cp (str or tuple): Color representing the compatible cases. **Default**: lime.
            showlegend (bool): Display legend (True/False).  **Default**: ``True``.

        Notes:
            `color_empty`, `incp` and `cp` must be color names or RGB values ranging between 0 and 1.

        Usage:
            * ``onevariable_plot(5, 2, color_empty=(0.5, 0.5, 0.5), incp=(0, 0, 1), cp=(0, 1, 0))``

        """

        cmap = mpl.colors.ListedColormap([incp, color_empty, cp])
        cmap.set_under(incp)
        cmap.set_over(cp)

        custom_lines = [Line2D([0], [0], marker='s', color=incp, lw=0.01, markersize=10),  # Customized legend
                        Line2D([0], [0], marker='s', color=cp, lw=0.01, markersize=10)]

        fig, axs = plt.subplots(nrows, ncols, facecolor='w', edgecolor='k')
        fig.subplots_adjust(hspace=.01, wspace=.1)

        axs = axs.ravel()

        for i in range(len(self.names)):

            comp = np.append(self.theo_asy[i, :] == self.numeric_asy,
                             0.5 * np.ones(self._n ** 2 - len(self.asy))).reshape((self._n, self._n))[::-1]
            comp = np.flip(comp, axis=0)

            axs[i].pcolormesh(comp, cmap=cmap, vmin=0.4, vmax=0.6)
            axs[i].hlines(y=np.arange(0, self._n + 1), xmin=0, xmax=self._n, color="k", linewidth=.5)
            axs[i].vlines(x=np.arange(0, self._n + 1), ymin=0, ymax=self._n, color="k", linewidth=.5)

            axs[i].set_aspect('equal')
            axs[i].get_xaxis().set_visible(False)
            axs[i].get_yaxis().set_visible(False)

        for ax in axs.flat[axs.size - 1:len(self.names) - 1:-1]:
            ax.set_visible(False)

        if showlegend:
            fig.legend(custom_lines, ['F', 'T'], loc='upper left', bbox_to_anchor=(1, 1), prop={'size': 14})

        plt.show()
